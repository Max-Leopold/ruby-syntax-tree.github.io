{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import \"./index.css\";\n\ntype SourceChangedEvent = { source: string };\ntype DisplayChangedEvent = { kind: \"prettyPrint\" | \"disasm\" };\n\nPromise.all([\n  // We're going to load the editor asynchronously so that we can get to\n  // first-paint faster. This works out nicely since we can use a textarea until\n  // this chunk is loaded.\n  import(\"./CodeMirror\").then(({ default: CodeMirror }) => {\n    const editor = document.getElementById(\"editor\") as HTMLTextAreaElement;\n    const newEditor = document.createElement(\"div\");\n    editor.replaceWith(newEditor);\n  \n    return CodeMirror(newEditor, {\n      lineNumbers: true,\n      mode: \"ruby\",\n      theme: \"xq-light\",\n      value: editor.value\n    });\n  }),\n  // We're going to load the Ruby VM chunk asynchronously because it is pretty\n  // dang huge (> 40Mb). In the meantime the textarea that is holding the place\n  // of the actual functional one is just going to display \"Loading...\".\n  import(\"./createRuby\").then(({ default: createRuby }) => createRuby())\n]).then(([editor, ruby]) => {\n  // First, grab a reference to the output element so that we can update it.\n  // Then, set it initially to the output represented by the source.\n  const output = document.getElementById(\"output\") as HTMLTextAreaElement;\n  output.value = ruby.prettyPrint(editor.getDoc().getValue());\n  output.disabled = false;\n\n  // This is the function that will be used to display the output from the\n  // source.\n  let displayFunction = ruby.prettyPrint;\n\n  // Handle a custom event here for if the display option changed.\n  output.addEventListener(\"display-changed\", (event: CustomEvent<DisplayChangedEvent>) => {\n    displayFunction = ruby[event.detail.kind];\n\n    try {\n      output.value = displayFunction(editor.getDoc().getValue());\n    } catch (error) {\n      // For now, just ignoring the error. Eventually I'd like to make this mark\n      // an error state on the editor to give feedback to the user.\n    }\n  });\n\n  // Hook into both the output toggles to make sure they send out the correct\n  // event information.\n  const toggles = document.getElementsByClassName(\"toggles\")[0];\n\n  toggles.querySelectorAll(\"button\").forEach((button) => {\n    button.disabled = (button.value === \"prettyPrint\");\n\n    button.addEventListener(\"click\", () => {\n      toggles.querySelectorAll(\"button\").forEach((toggle) => {\n        toggle.disabled = (button.value === toggle.value);\n      });\n\n      output.dispatchEvent(new CustomEvent<DisplayChangedEvent>(\"display-changed\", {\n        detail: { kind: button.value as DisplayChangedEvent[\"kind\"] }\n      }));\n    });\n  });\n\n  // We're going to handle updates to the source through a custom event. This\n  // turns out to be faster than handling the change event directly on the\n  // editor since it blocks updates to the UI until the event handled returns.\n  output.addEventListener(\"source-changed\", (event: CustomEvent<SourceChangedEvent>) => {\n    try {\n      output.value = displayFunction(event.detail.source);\n    } catch (error) {\n      // For now, just ignoring the error. Eventually I'd like to make this mark\n      // an error state on the editor to give feedback to the user.\n    }\n  });\n\n  // Attach to the editor and dispatch custom source-changed events whenever the\n  // value is updated in the editor.\n  editor.on(\"change\", () => {\n    output.dispatchEvent(new CustomEvent<SourceChangedEvent>(\"source-changed\", {\n      detail: { source: editor.getDoc().getValue() }\n    }));\n  });\n\n  // Attach to the format button to update the source whenever the button is\n  // clicked.\n  const format = document.getElementById(\"format\");\n  format.disabled = false;\n\n  format.addEventListener(\"click\", () => {\n    editor.getDoc().setValue(ruby.format(editor.getValue()));\n  });\n});\n"],
  "mappings": "4BAKA,QAAQ,IAAI,CAIV,OAAO,4BAAgB,KAAK,CAAC,CAAE,QAAS,KAAiB,CACvD,GAAM,GAAS,SAAS,eAAe,QAAQ,EACzC,EAAY,SAAS,cAAc,KAAK,EAC9C,SAAO,YAAY,CAAS,EAErB,EAAW,EAAW,CAC3B,YAAa,GACb,KAAM,OACN,MAAO,WACP,MAAO,EAAO,KAChB,CAAC,CACH,CAAC,EAID,OAAO,4BAAgB,KAAK,CAAC,CAAE,QAAS,KAAiB,EAAW,CAAC,CACvE,CAAC,EAAE,KAAK,CAAC,CAAC,EAAQ,KAAU,CAG1B,GAAM,GAAS,SAAS,eAAe,QAAQ,EAC/C,EAAO,MAAQ,EAAK,YAAY,EAAO,OAAO,EAAE,SAAS,CAAC,EAC1D,EAAO,SAAW,GAIlB,GAAI,GAAkB,EAAK,YAG3B,EAAO,iBAAiB,kBAAmB,AAAC,GAA4C,CACtF,EAAkB,EAAK,EAAM,OAAO,MAEpC,GAAI,CACF,EAAO,MAAQ,EAAgB,EAAO,OAAO,EAAE,SAAS,CAAC,CAC3D,OAAS,EAAP,CAGF,CACF,CAAC,EAID,GAAM,GAAU,SAAS,uBAAuB,SAAS,EAAE,GAE3D,EAAQ,iBAAiB,QAAQ,EAAE,QAAQ,AAAC,GAAW,CACrD,EAAO,SAAY,EAAO,QAAU,cAEpC,EAAO,iBAAiB,QAAS,IAAM,CACrC,EAAQ,iBAAiB,QAAQ,EAAE,QAAQ,AAAC,GAAW,CACrD,EAAO,SAAY,EAAO,QAAU,EAAO,KAC7C,CAAC,EAED,EAAO,cAAc,GAAI,aAAiC,kBAAmB,CAC3E,OAAQ,CAAE,KAAM,EAAO,KAAqC,CAC9D,CAAC,CAAC,CACJ,CAAC,CACH,CAAC,EAKD,EAAO,iBAAiB,iBAAkB,AAAC,GAA2C,CACpF,GAAI,CACF,EAAO,MAAQ,EAAgB,EAAM,OAAO,MAAM,CACpD,OAAS,EAAP,CAGF,CACF,CAAC,EAID,EAAO,GAAG,SAAU,IAAM,CACxB,EAAO,cAAc,GAAI,aAAgC,iBAAkB,CACzE,OAAQ,CAAE,OAAQ,EAAO,OAAO,EAAE,SAAS,CAAE,CAC/C,CAAC,CAAC,CACJ,CAAC,EAID,GAAM,GAAS,SAAS,eAAe,QAAQ,EAC/C,EAAO,SAAW,GAElB,EAAO,iBAAiB,QAAS,IAAM,CACrC,EAAO,OAAO,EAAE,SAAS,EAAK,OAAO,EAAO,SAAS,CAAC,CAAC,CACzD,CAAC,CACH,CAAC",
  "names": []
}
