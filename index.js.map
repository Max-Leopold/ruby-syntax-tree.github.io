{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import \"./index.css\";\n\nPromise.all([\n  // We're going to load the editor asynchronously so that we can get to\n  // first-paint faster. This works out nicely since we can use a textarea until\n  // this chunk is loaded.\n  import(\"./CodeMirror\").then(({ default: CodeMirror }) => {\n    const editor = document.getElementById(\"editor\") as HTMLTextAreaElement;\n    const newEditor = document.createElement(\"div\");\n    editor.replaceWith(newEditor);\n  \n    return CodeMirror(newEditor, {\n      lineNumbers: true,\n      mode: \"ruby\",\n      theme: \"xq-light\",\n      value: editor.value\n    });\n  }),\n  // We're going to load the Ruby VM chunk asynchronously because it is pretty\n  // dang huge (> 40Mb). In the meantime the textarea that is holding the place\n  // of the actual functional one is just going to display \"Loading...\".\n  import(\"./createRuby\").then(({ default: createRuby }) => createRuby())\n]).then(([editor, ruby]) => {\n  // First, grab a reference to the tree element so that we can update it. Then,\n  // set it initially to the tree represented by the source already there.\n  const tree = document.getElementById(\"tree\") as HTMLTextAreaElement;\n  tree.value = ruby.prettyPrint(editor.getDoc().getValue());\n  tree.disabled = false;\n\n  // We're going to handle updates to the source through a custom event. This\n  // turns out to be faster than handling the change event directly on the\n  // editor since it blocks updates to the UI until the event handled returns.\n  tree.addEventListener(\"source-changed\", (event: CustomEvent<{ source: string }>) => {\n    try {\n      tree.value = ruby.prettyPrint(event.detail.source);\n    } catch (error) {\n      // For now, just ignoring the error. Eventually I'd like to make this mark\n      // an error state on the editor to give feedback to the user.\n    }\n  });\n\n  // Attach to the editor and dispatch custom source-changed events whenever the\n  // value is updated in the editor.\n  editor.on(\"change\", () => {\n    tree.dispatchEvent(new CustomEvent<{ source: string }>(\"source-changed\", {\n      detail: { source: editor.getDoc().getValue() }\n    }));\n  });\n\n  // Attach to the format button to update the source whenever the button is\n  // clicked.\n  document.getElementById(\"format\").addEventListener(\"click\", () => {\n    editor.getDoc().setValue(ruby.format(editor.getValue()));\n  });\n});\n"],
  "mappings": "4BAEA,QAAQ,IAAI,CAIV,OAAO,4BAAgB,KAAK,CAAC,CAAE,QAAS,KAAiB,CACvD,GAAM,GAAS,SAAS,eAAe,QAAQ,EACzC,EAAY,SAAS,cAAc,KAAK,EAC9C,SAAO,YAAY,CAAS,EAErB,EAAW,EAAW,CAC3B,YAAa,GACb,KAAM,OACN,MAAO,WACP,MAAO,EAAO,KAChB,CAAC,CACH,CAAC,EAID,OAAO,4BAAgB,KAAK,CAAC,CAAE,QAAS,KAAiB,EAAW,CAAC,CACvE,CAAC,EAAE,KAAK,CAAC,CAAC,EAAQ,KAAU,CAG1B,GAAM,GAAO,SAAS,eAAe,MAAM,EAC3C,EAAK,MAAQ,EAAK,YAAY,EAAO,OAAO,EAAE,SAAS,CAAC,EACxD,EAAK,SAAW,GAKhB,EAAK,iBAAiB,iBAAkB,AAAC,GAA2C,CAClF,GAAI,CACF,EAAK,MAAQ,EAAK,YAAY,EAAM,OAAO,MAAM,CACnD,OAAS,EAAP,CAGF,CACF,CAAC,EAID,EAAO,GAAG,SAAU,IAAM,CACxB,EAAK,cAAc,GAAI,aAAgC,iBAAkB,CACvE,OAAQ,CAAE,OAAQ,EAAO,OAAO,EAAE,SAAS,CAAE,CAC/C,CAAC,CAAC,CACJ,CAAC,EAID,SAAS,eAAe,QAAQ,EAAE,iBAAiB,QAAS,IAAM,CAChE,EAAO,OAAO,EAAE,SAAS,EAAK,OAAO,EAAO,SAAS,CAAC,CAAC,CACzD,CAAC,CACH,CAAC",
  "names": []
}
